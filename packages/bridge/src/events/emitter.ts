import {
  type InferOutput,
  parse,
  pipe,
  string,
  looseObject,
  optional,
  unknown,
  number,
  boolean,
  nullish,
  type BaseSchema,
} from 'valibot';
import { jsonParse, MiniAppsMessageSchema } from '@telegram-apps/transformers';

import { createEmitter } from '@/events/createEmitter.js';
import type { EventName, EventPayload, Events } from '@/events/types/index.js';
import { emitEvent } from '@/events/emitEvent.js';
import { logError } from '@/debug.js';

/**
 * Transformers for problematic Mini Apps events.
 */
const transformers = {
  clipboard_text_received: looseObject({
    req_id: string(),
    data: nullish(string()),
  }),
  custom_method_invoked: looseObject({
    req_id: string(),
    result: optional(unknown()),
    error: optional(string()),
  }),
  popup_closed: nullish(
    looseObject({ button_id: nullish(string(), () => undefined) }),
    {},
  ),
  viewport_changed: looseObject({
    height: number(),
    width: nullish(number(), () => window.innerWidth),
    is_state_stable: boolean(),
    is_expanded: boolean(),
  }),
} as const satisfies { [E in EventName]?: BaseSchema<unknown, EventPayload<E>, any> };

function listener(event: MessageEvent): void {
  // Ignore non-parent window messages.
  if (event.source !== window.parent) {
    return;
  }

  // Parse incoming event data.
  let message: InferOutput<typeof MiniAppsMessageSchema>;
  try {
    message = parse(pipe(string(), jsonParse(), MiniAppsMessageSchema), event.data);
  } catch {
    // We ignore incorrect messages as they could be generated by any other code.
    return;
  }

  const { eventType, eventData } = message;
  const schema = transformers[eventType as keyof typeof transformers];
  try {
    const data = schema ? parse(schema, eventData) : eventData;
    emit(eventType as any, data);
  } catch (cause) {
    logError(
      true,
      [
        `An error occurred processing the "${eventType}" event from the Telegram application.`,
        'Please, file an issue here:',
        'https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose',
      ].join('\n'),
      message,
      cause,
    );
  }
}

export const [
  on,
  off,
  emit,
  offAll,
] = createEmitter<Events>(
  () => {
    const w = window as any;

    // Define all functions responsible for receiving an event from the Telegram client.
    // All these "ports" should narrow the communication way to a single specific one - the way
    // accepted by the web version of Telegram between iframes.
    const obj = { receiveEvent: emitEvent };
    w.TelegramGameProxy_receiveEvent = emitEvent;
    w.TelegramGameProxy = obj;
    w.Telegram = { WebView: obj };

    // Add a listener handling events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    // This handler should emit a new event using the library event emitter.
    window.addEventListener('message', listener);
  },
  () => {
    ['TelegramGameProxy_receiveEvent', 'TelegramGameProxy', 'Telegram'].forEach((prop) => {
      delete (window as any)[prop];
    });
    window.removeEventListener('message', listener);
  },
);
